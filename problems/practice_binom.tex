\begin{problem}{\kcpcpprobbinom\ (\kcpcpprobbinomshort)}
    {표준 입력}{표준 출력}
    {\kcpcpprobbinomtime\,초}{\kcpcpprobbinommemory\,MB}{}
    
    $_{n}C_{r}$로도 표현되는 이항 계수 $\binom{n}{r}$이 $\frac{n!}{r!(n-r)!}$으로 정의된다는 점은 익히 들어보았을 것이다. 수학에 관심이 있다면, 파스칼의 삼각형을 통해 다음 점화식이 성립한다는 것도 알 것이다.
    \begin{align*}
        \binom{n}{r} = \binom{n-1}{r-1} + \binom{n-1}{r}
    \end{align*}
    때문에 이항 계수의 계산은 동적 계획법에서 memoization의 대표적인 예시로 쓰인다. 의사 코드를 작성해보면 다음과 같다.
    \begin{verbatim}
def binom(n, r):
    if dp[n][r] > 0:
        return dp[n][r]
    if n == 0:
        return dp[n][r] = 1
    if r == 0:
        return dp[n][r] = binom(n-1, r)
    if r == n:
        return dp[n][r] = binom(n-1, r-1)
    return dp[n][r] = binom(n-1, r) + binom(n-1, r-1)
\end{verbatim}
    여기서 \verb|dp[n][r]|은 $\binom{n}{r}$을 저장해놓는 배열로, 처음에는 0으로 초기화되어 있으나 값이 한 번 계산되면 양의 정수로 갱신된다. 때문에 첫 번째 조건문에 의해, 한 번 조사된 값은 조사되거나 갱신되지 않는다. 또, 이 함수는 초기 $n, r$이 $ 0 \leq r \leq n$을 만족하면 호출되는 모든 \verb|binom|도 해당 조건을 만족한다.
    
    상헌이는 이항 계수를 여러 번 질문할 때마다, 몇 개의 이항 계수들이 \verb|dp| 배열에 새롭게 계산되어 갱신되는지 알고 싶어한다. 이항 계수 문제는 아니지만 한 번 풀어보자.
    
    \InputFile
    첫 번째 줄에는 \verb|binom| 함수의 호출 횟수인 정수 $q$가 주어진다. $ (1 \leq q \leq 80,000) $
    
    이후 $q$개의 줄에 걸쳐 두 정수 $n$, $r$이 공백으로 구분되어 주어진다. $ (0 \leq r \leq n \leq 80,000) $ 이는 \verb|binom(n, r)|을 호출한다는 뜻이다.
    
    \OutputFile
    
    각 줄마다 \verb|binom(n, r)|을 호출했을 때 갱신되는 \verb|dp| 배열의 칸 개수를 출력한다. 매 \verb|binom| 함수의 결과로 갱신된 \verb|dp|는 그 이후로도 계속 적용된다.
    
    \Examples
    \begin{example}
        \exmp{
            4
            2 1
            3 1
            6 3
            3 2
        }{%
            4
            2
            10
            0
        }%
         \exmp{
            3
            4 2
            5 4
            6 3
        }{%
            9
            4
            5
        }%
    \end{example}

    \Explanation
    첫 번째 예제에 대한 설명은 다음과 같다.
    \begin{itemize}
        \item \verb|binom(2, 1)|은 \verb|(2,1), (1,0), (0,0), (1,1)|을 갱신한다.
        \item \verb|binom(3, 1)|은 \verb|(3,1), (2,0)|을 갱신한다.
        \item \verb|binom(6, 3)|은 \verb|(6,3), (5,2), (4,1), (3,0), (4,2), (3,2), (2,2), (5,3), (4,3), (3,3)|을 갱신한다.
        \item \verb|binom(3, 2)|은 어느 칸도 갱신하지 않는다. 3번째 호출에서 \verb|(3,2)|가 갱신되었기 때문이다.
    \end{itemize}

\end{problem}

